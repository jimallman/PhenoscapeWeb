<h3>All phenotypes for <span class="term-name" title="<%=h @entity["id"] %>"><a href="/search/entity/<%=h @entity["id"] %>"><%=h @entity["name"] %></a></span> <%= quality_link(@quality) %>
<% if @subject != nil %>
in <%= taxon_link(@subject) %>
<% end %>
</h3>

<div id="phenotype-tree">
</div>


<script type="text/javascript">

/*
Functions for displaying annotation sources need to be stored in a dictionary and referenced later by matching with A element ID.
This is because the Yahoo tree widget requires content HTML to be provided with text, preventing attaching functions as click listeners to the A elements as they are added to the DOM.
*/
var sourceLinks = {};

var sourceLinkIDGenerator = {
	"i" : 0,
	
	"next" : function() {
		return "sourcelinkID" + this["i"]++;
	}
};

var entity = <%= @entity.to_json %>;
var quality = <%= @quality.to_json %>;
var rootData = <%= @root.to_json %>;

var tree = new YAHOO.widget.TreeView("phenotype-tree");
createNodeForTaxon(rootData, tree.getRoot());
tree.setDynamicLoad(requestDataForChildren);
tree.subscribe("clickEvent", function(arg) {
	var targetID = arg["event"]["target"]["id"];
	if ((targetID != null) && (sourceLinks[targetID] != null)) {
		sourceLinks[targetID]();
	}
	//disable clicking on whole node to expand/collapse - this allows links inside node to work properly
	return false;
});
tree.render();
YAHOO.util.Event.onDOMReady(function() {
	expandRoot();
});

function expandRoot() {
	for (var i = 0; i < tree.getRoot().children.length; i++) {
		tree.getRoot().children[i].expand();
	}
}

function requestDataForChildren(parentNode, callback) {
	var dataGetter = MochiKit.Async.loadJSONDoc(URL.childPhenotypes(entity["id"], quality["id"], parentNode["data"]["id"]));
	dataGetter.addCallback(function(result) {
		loadDataForChildren(parentNode, callback, result);
	});
	dataGetter.addErrback(function(result) {
		//TODO - should put some kind of data error alert next to taxon - and remove alert
		alert(result);
		callback();
	});
}

function loadDataForChildren(parentNode, callback, result) {
	for (var i = 0; i < result["subjects"].length; i++) {
		var taxon = result["subjects"][i];
		createNodeForTaxon(taxon, parentNode);
	}
	callback();
}

function createNodeForTaxon(taxonData, parentNode) {
	var phenotypes = taxonData.phenotypes;
	phenotypes.sort(function(a, b) {
		var entity = MochiKit.Base.compare(a["entity"]["name"], b["entity"]["name"]);
		if (entity == 0) {
			var quality = MochiKit.Base.compare(a["quality"]["name"], b["quality"]["name"]);
			if (quality == 0) {
				return MochiKit.Base.compare(a["count"], b["count"]);
			} else {
				return quality;
			}
		} else {
			return entity;
		}
	});
	var clazz = null;
	if (italicTaxon(taxonData)) {
		clazz = "italic-taxon"
	}
	var taxonName = MochiKit.DOM.A({href: URL.taxon(taxonData["id"]), title: taxonData["id"], "class": clazz}, taxonData["name"]);
	var phenotypesContainer = MochiKit.DOM.SPAN({"class": "phenotype-block"});
	for (var i = 0; i < phenotypes.length; i++) {
		var phenotype = phenotypes[i];
		var phenotypeItem = createListItemForPhenotype(phenotype);
		MochiKit.DOM.appendChildNodes(phenotypesContainer, phenotypeItem);
		if ((i + 1) < phenotypes.length) {
			MochiKit.DOM.appendChildNodes(phenotypesContainer, ", ");
		}
	}
	var subtaxaCount = "";
	if (!taxonData["leaf"]) {
		subtaxaCount = " (" + taxonData["annotated_taxa_count"] + ")";
	}
	var container = MochiKit.DOM.DIV({"class": "tree-row"}, taxonName, subtaxaCount, MochiKit.DOM.SPAN({"class": "dotted-line"}, "........................."), phenotypesContainer);
	var outer = MochiKit.DOM.DIV(null, container);
	var node = new YAHOO.widget.HTMLNode({"html" : outer.innerHTML, "data" : taxonData, "href": null, "isLeaf" : taxonData["leaf"]}, parentNode);
	// don't allow blue focus color
	node.focus = function() {return true;};
	if (node.depth % 2 == 0) {
		node["className"] = "tree-depth-even";
	} else {
		node["className"] = "tree-depth-odd";
	}
	return node;
}

function createListItemForPhenotype(phenotypeData) {
	var entity = phenotypeData.entity;
	var quality = phenotypeData.quality;
	var count = phenotypeData.count;
	var entityName = MochiKit.DOM.A({href: URL.entity(entity["id"]), title: entity["id"]}, entity["name"]);
	var qualityName = MochiKit.DOM.A({href: URL.quality(quality["id"]), title: quality["id"], "target": "_blank"}, quality["name"]);
	var container = MochiKit.DOM.SPAN(null, entityName, " ", qualityName);
	if ((count != null) && (count != "")) {
		MochiKit.DOM.appendChildNodes(container, ", " + count);
	}
	if ((phenotypeData["id"] != null) && (phenotypeData["id"].length != 0)) {
		var idList = phenotypeData["id"];
		var sourceLinkID = sourceLinkIDGenerator.next();
		var sourceLink = MochiKit.DOM.A({"href": "#"}, MochiKit.DOM.IMG({"src": "/images/page_text.gif", "id": sourceLinkID}));
		sourceLinks[sourceLinkID] = function() {
			showSource(idList, $(sourceLinkID));
		}
		MochiKit.DOM.appendChildNodes(container, " ", sourceLink);
	}
	return container;
}

var deferred = null;

function showSource(id, element) {
	var sourcePanel = new YAHOO.widget.Panel("source_panel", {
		"context" : [element, YAHOO.widget.Overlay.TOP_RIGHT, YAHOO.widget.Overlay.BOTTOM_LEFT],
		"constraintoviewport" : true,
		"visible" : false
		});
	sourcePanel.hideEvent.subscribe(destroyPanel, sourcePanel);
	var img = MochiKit.DOM.IMG({"src":"/images/rotation.gif", "alt":"loading"});
	var div = MochiKit.DOM.DIV(null, img);
	sourcePanel.setBody(div);
	sourcePanel.setHeader("Loading...");
	if (deferred) { deferred.cancel(); }
	deferred = MochiKit.Async.loadJSONDoc(URL.source([id]));
	deferred.addCallback(MochiKit.Base.partial(fillInSource, sourcePanel));
	sourcePanel.render(document.body);
	sourcePanel.show();
}

function fillInSource(panel, content) {
	MochiKit.DOM.replaceChildNodes(panel.header, "Source Data");
	var taxonClass = "";
	if (italicTaxon(content["phenotype"]["subject"])) {
		taxonClass = "italic-taxon";
	}
	var taxon = MochiKit.DOM.SPAN({"class": taxonClass}, content["phenotype"]["subject"]["name"]);
	var entity = MochiKit.DOM.SPAN(null, content["phenotype"]["entity"]["name"]);
	var quality = MochiKit.DOM.SPAN(null, content["phenotype"]["quality"]["name"]);	
	var statement = MochiKit.DOM.P({"class": "phenotype-statement-source"}, entity, " ", quality, " in ", taxon);
	var sources = MochiKit.Base.map(function(item) {
		var citation = MochiKit.DOM.P(null);
		citation.innerHTML = item["publication"]; //using innerHTML here to make use of HTML formatting in publication titles
		var number = item["character_number"];
		var characterLabel = "character";
		if ((number != null) && (number != "")) {
			characterLabel += " " + number;
		}
		characterLabel += ":";
		var characterTable = MochiKit.DOM.TABLE(null, MochiKit.DOM.TR(null, MochiKit.DOM.TD({"class": "label"}, characterLabel), MochiKit.DOM.TD(null, item["character_text"])));
		if (!MochiKit.Base.isUndefinedOrNull(item["character_comment"]) && (item["character_comment"].length > 0)) {
			var character_comment = MochiKit.DOM.P({"style":"display: none;", "class":"character_comment"}, item["character_comment"]);
			var character_revealer = MochiKit.DOM.A({"href":"#"}, "View comment");
			var character_revealerBlock = MochiKit.DOM.P(null, character_revealer);
			MochiKit.Signal.connect(character_revealer, "onclick", function() {
				MochiKit.DOM.hideElement(character_revealerBlock);
				MochiKit.Visual.blindDown(character_comment);
				return false;
			});
			var character_commentRow = MochiKit.DOM.TR(null, MochiKit.DOM.TD({"colspan":"2"}, character_revealerBlock, character_comment));
			MochiKit.DOM.appendChildNodes(characterTable, character_commentRow);
		}
		MochiKit.DOM.appendChildNodes(characterTable, MochiKit.DOM.TR(null, MochiKit.DOM.TD({"class": "label"}, "state:"), MochiKit.DOM.TD(null, item["state_text"])));
		if (!MochiKit.Base.isUndefinedOrNull(item["state_comment"]) && (item["state_comment"].length > 0)) {
			var state_comment = MochiKit.DOM.P({"style":"display: none;", "class":"character_comment"}, item["state_comment"]);
			var state_revealer = MochiKit.DOM.A({"href":"#"}, "View comment");
			var state_revealerBlock = MochiKit.DOM.P(null, state_revealer);
			MochiKit.Signal.connect(state_revealer, "onclick", function() {
				MochiKit.DOM.hideElement(state_revealerBlock);
				MochiKit.Visual.blindDown(state_comment);
				return false;
			});
			var state_commentRow = MochiKit.DOM.TR(null, MochiKit.DOM.TD({"colspan":"2"}, state_revealerBlock, state_comment));
			MochiKit.DOM.appendChildNodes(characterTable, state_commentRow);
		}
		return MochiKit.DOM.DIV({"class": "citation-item"}, citation, characterTable);
	}, content["sources"]);
	MochiKit.DOM.replaceChildNodes(panel.body, statement, sources);
}

function destroyPanel(type, args, obj) {
	MochiKit.Logging.logDebug("Destroy");
	if (deferred) { deferred.cancel(); }
	obj.destroy();
}

</script>